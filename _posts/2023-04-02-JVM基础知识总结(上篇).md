---
title: JVM基础知识总结(上篇)
date: 2023-04-02 22:21:33
categories: [Java, Jvm]
tags: [Java] # TAG names should always be lowercase
---

# JVM 基础知识总结

### jclasslib 插件在 idea 中显示中文问题

- 该问题是因为 jclasslib 加入了检测本地语言环境造成的，我们可以通过修改 vm 虚拟机配置来解决此问题。
- Help ->Edit Custom Option... 在配置文件中加入

```
# 语言环境为英文
-Duser.language=en
# 地区为中国
-Duser.region=CN
```

### 堆空间

##### 常见参数设置

```
-Xms10m ==> -XX:InitialHeapSize	设置初始堆空间
-Xmx20m	==> -XX:MaxHeapSize	最大堆空间
```

##### 堆内存细分

```
在jdk1.7中，堆内存分为新生代，老年代和永久代
在jdk1.8中，对内存分为新生代，老年代和元空间。
```

##### 命令行常用指令

```
jps --查看当前java进程
jstat -gc pid 查看当前进程堆分配情况
```

##### 设置堆内存中新生代和老年代的比例

```
-XX:NewRatio -- 默认值为2 即新生代：老年代 = 1:2 一般不会调整，除非进程中存在大量的生命周期较长的对象

	Eden 与survivor 区的比例为8:1:1 但是虚拟机会有自适应算法，比例为6
-XX:Survivor 8 可以指定

-Xmn  -- 设置新生代空间的大小（如果同时设置了-NewRatio 那么则以—Xmn为准）

-XX:MaxTenuringThreshold: 设置新生代垃圾的最大年龄
-XX：HandlePromotionFailure:是否设置空间分配担保


-XX:-DoEscapeAnalysis -- 是否开启逃逸分析
```

#### 对空间垃圾回收

##### Minor GC 、 Major GC、 Full GC

- Minor GC / Young GC -- 只是新生代的垃圾回收
- Major GC / Old GC -- 只是老年代的垃圾收集
  - 目前只有 CMS GC 会有单独回收老年代垃圾的行为
  - 很多时候，Major GC 和 Full GC 会混淆使用，需要区分的是老年代回收和整堆回收
  - 混合收集（Mixed GC） 收集新生代及部分老年代的垃圾
    - 目前只有 G1 GC 有这种行为
- Full GC (整堆收集) ：收集整个堆和方法区的垃圾。
- 打印 GC 日志参数设置

```
-XX:PrintGCDetails
```

### 逃逸分析

- 如果开启了逃逸分析，如果 jvm 检测到对象未发生逃逸，那么则会将对象分配优化为栈分配。
- 如果开启了逃逸分析，如果 jvm 检测到对象未发生逃逸，jvm 则会进行同步省略。
- 如果开启了逃逸分析，如果 jvm 检测到对象未发生逃逸，那么 jvm 会进行标量替换 -XX:EliminateAllocations

## 方法区

### 元空间和永久代

- 元空间和永久代的本质区别:永久代使用的是 jvm 虚拟机的内存，元空间使用的是本地的物理内存。

### 方法区相关参数设置

- 方法区的大小不必是固定的，jvm 虚拟机会根据应用的需要进行动态调整。
- 在 jdk7 前：（jdK8 中被废弃）

```
-XX:PermSize --设置永久代初始分配空间，默认大小为20.75M
-XX:MaxPermSize -- 设置永久代最大可分配空间，32位机器默认为64M，64位机器默认为82M
```

- 在 jdk8 及以后，使用元空间代替永久代

```
-XX:MetaspaceSize=size -- 设置元空间初始分配空间，默认为约21M。
-XX:MaxMetaspaceSize=size -- 设置元空间最大分配空间，默认为-1，即没有限制。
```

### 方法区的演进细节

###### HotSpot 虚拟机方法区的变化

| jdk1.6 | 有永久代，静态变量存放在永久代上。                                                             |
| ------ | ---------------------------------------------------------------------------------------------- |
| jdk1.7 | 有永久代，但是已经逐渐去永久代，字符常量池，静态变量移除，存放在堆中。                         |
| jdk1.8 | 无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符常量池，静态变量仍然在堆中。 |

###### 为什么要用元空间取代永久代

- 为永久代设置空间大小很难确定。
- 对永久代调优困难。

###### 为什么要移动 StringTable

放在方法区（永久代）我们执行 full GC 的频率很低，造成资源浪费。

## 类的加载

- 判断类是否被加载，连接、初始化
- 为对象分配空间
  - 如果内存规整（指针碰撞）
  - 如果内存不规整（虚拟机需要维护一个列表，找到哪些内存块是可用的，然后只需要找到其中的一块足够的空间进行分配使用）
  - 采用那种方式取决于 gc 垃圾回收的算法（是否压缩）
- 解决并发问题
  - 采用 CAS 失败重试，区域加锁保证更新的原子性
  - 每个线程分配一块 TLAB-- 通过-XX:+/-UseTLAB 来设定
- 初始化分配到的空间
  - 所有属性进行初始化，默认赋值。
- 设置对象的头
- 执行对象显式初始化，代码块初始化，构造器初始化。

### 对象访问定位方式

- 句柄访问（在堆中维护一个句柄池来记录对象的引用地址，和对象类型信息地址）
  - 优点:当对象发生移动时（对象标志整理算法相关），不需要修改栈帧中的引用地址，只需要改变句柄池中的值
  - 缺点：需要一块额外的空间来维护一个句柄池
- 直接访问（Hotspot 使用）
  - 优点：较句柄访问不需要开额外的空间
  - 缺点：每次对象发生移动时，局部变量表中的引用地址也需要被改变。

## 直接内存

不是虚拟机运行时数据区的一部分，也不包含在《Java 虚拟机规范》

### JIT 编译器

##### 方法调用计数器：

- 用于统计方法被调用的次数，当方法调用次数超过阈值，则会触发 JIT 编译器

- 阈值：client 客户端默认值为 5000 server 默认值为 10000

##### 热度衰减

- 如果未进行任何设置，方法调用计数器并不是统计绝对的次数，而是方法调用的频率，即一段时间内方法被调用的次数，当超过了这个时间限度，方法调用次数依然不足提交给 JIT 编译器的次数，那么这个方法的调用计数器就会减少一半，这个过程称为热度的衰减，而这个时间称为这个方法统计的半衰周期。

##### 回边计数器：

- 统计方法中循环体代码的执行次数

##### 常用参数设置：

```
-XX:CompileThreshold --设置阈值大小
-XX:-UseCounterDecay --关闭热度衰减
-XX：CounterHalfLifeTime -- 设置半衰周期时间

-XX:OnStackReplacePercentage -- 设置ORS比率，通过设置ORS比率来间接设置回边计数器阈值

-Xint  -- 设置为纯解释器模式
-Xcomp -- 设置为纯编译器
-Xmixed -- 混合模式

```

## StringTable

##### 常用参数设置

- String 是在 String Pool 中维护一个 HashTable 数组（默认长度是 1009 在 jdk6 中），那么，如果字符常量池中存放的字符串数量过多会造成 Hash 冲突，那么就会导致每个位置生成链表，如果链表长度过长，那么就会造成查询效率的下降。

- jdk6 中 Hash

```
-XX:StringTableSize100(byte[]大小) --默认值大小为1009
```

```
-XX:+PrintStringTableStatistics --控制台打印常量池信息
```

##### StringTable 为什么要从永久代调整到堆中

- permSize 大小较小
- 永久代垃圾回收频率低

## 垃圾回收

##### 什么是垃圾：

- 垃圾是指在运行过程中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。

##### 为什么需要进行垃圾回收：

- 对于高级语言来说一个基本的认知是，如果不进行垃圾回收，那么系统内存迟早会被消耗完。
- 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片，碎片将被移动到堆内存的一端，以便 JVM 整理出来的内存用于分配给新的对象。
- 随着程序所应付的业务越来越庞大，复杂，没有 GC 就不能保证程序的正常进行。

##### 判断对象是否存活：

- 引用计数算法（java 未使用）
  - 缺点：存在循环引用问题，导致垃圾永远不会被回收，存在内存泄漏。
  - 好处：执行高效。
  - 使用该算法的语言 Python，如何解决循环引用的问题
    - 手动解除：在合适的时机，手动解除引用关系
    - 使用弱引用 weakref，weakref 是 Python 提供的标准库，旨在解决循环引用问题。
- 可达性分析算法

  - 有点，解决引用计数算法存在的循环引用的问题。

  - GC Roots 可以包含哪些元素：

    - 虚拟机栈中引用的对象
    - 本地方法栈内 JNI（通常说的本地方法）引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象
    - 所有被同步锁 synchronized 持有的对象
    - Java 虚拟机内部的引用

    - 特别的：除了上述的一些 GC Roots 集合外，根据用户所选用的垃圾回收器以及当前回收区域的不同，还可以有其他的对象临时的加入，共同构成 GC Roots,如分代回收和局部回收（Partial GC）

##### 标记-清除算法：

- 标记：将 GC Roots 中可达的
- 对象进行标记（不是标记垃圾，而是标记非垃圾）
- 清除：将未被标记的对象的内存地址放入到空闲列表中。
- 缺点：
  - 效率较低（但不是最低）
  - 在进行 GC 时，需要 STW，用户体验不太好
  - 清理出来的内存是不联系的，会产生内存的碎片，需要维护一个空闲列表

##### 复制算法

- 优点

  - 没有标记和清除的过程，简单高效

  - 复制过后的空间是连续的

- 缺点

  - 需要两倍的内存空间
  - 复制不是移动，需要维护 region 的引用关系

##### 标记整理算法

- 优点
  - 解决内存碎片问题
- 缺点
  - 效率最低

##### 增量收集算法

- 优点
  - 解决在垃圾回收过程中存在的 stop the world 问题，提升用户体验
- 缺点
  - 在垃圾回收的过程中，间断去执行 应用程序代码，会导致线程的上下文切换消耗掉 CPU 资源，使得垃圾回收成本上升，降低系统吞吐量

##### 分区算法（主要针对 G1 垃圾回收器）

- 当堆内存空间较大时，每次回收需要耗费大量的时间，我们可以将堆空间划分成多个较小的区域，然后根据需求停顿时间，选择性的回收一部区域。

总结：以上算法都只是算法的基本思路，实际垃圾回收算法往往复杂的多，实际过程中往往都是多种算法混合使用。

##### 安全点（safepoint）

- 在程序执行期间所有的 GC Root 已知并且所有堆对象内容一致的点
- 从全局角度看，所有线程在 GC 之前必须在安全端阻塞
- 从本地来看，安全点是一个显著的点，它位于执行线程可能阻止 gc 的代码块中，大多数调用都可作为安全点

##### 安全区域

- 对象引用没有发生改变的代码区域

#### 再谈引用

##### 强引用

- 就是传统意义上的引用，程序中的引用赋值，在垃圾回收的过程中，如果引用关系还存在，那么就永远不会被回收。

##### 软引用

- 在系统将要发生内存溢出之前，会将这些对象放入回收范围内进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常

##### 弱引用

- 被弱引用的对象只能生存到下次垃圾回收之前，无论引用关系是否存在，都会被垃圾回收回收掉

##### 虚引用

- 一个具有虚引用的对象，完全不会对其生存时间构成印象，也无法通过虚引用获得该对象的示例，唯一的目的就是会受到一个对象回收的通知

##### 垃圾回收器

- 评价垃圾回收器的评价指标：
  - 吞吐量
  - 暂停时间

#### 常见的垃圾回收器

- 串行回收器：

  - Serial、Serial Old
    - Serial 采用标记-复制算法，串行回收 stw 机制的方式执行垃圾回收
    - Serial Old 采用标记-整理算法。是 client 模式下默认老年代的垃圾回收器
  - ` 使用SerialGC -XX:+UserSerialGC  -- 年轻代老年代都会设置`
  - 在用户注重交互的应用中，这种垃圾回收器一般是难以接受的（stop the world！）。

- 并行回收器

  - ParNew、Parallel Scavenge、 Parallel Old

    - Parallel 注重高吞吐量，适合于和用户交互较少的场景，如批量处理，订单处理，科学计算等。

    - Parallel Old 采用了标记-整理算法，同样是并行处理和“Stop the world” 机制。在 jdk8 中，是默认的垃圾回收器。

    - 常用参数

      ```
      -XX:+UseParallelGC
      -XX:+UseParallelOldGC
      二者可以相互激活
      -XX:ParallelGCThreads10 设置并行收集器的线程数
      	在默认情况下，当cpu的个数小于8个时，我们设置个数为cpu个数。
      	当cpu数量大于等于8个时，我们设置3+[5*cpu_count]/8

      -XX:MaxGCPauseMillis	设置垃圾回收器最大停止时间，单位是毫秒，为了满足设置的停止时间，jvm会通过调整队的大小来满足该暂停时间（尽可能满足该时间）。
      该参数需要谨慎使用。
      -XX:GCTimeRatio   	垃圾回收占总时间比例。用于衡量吞吐量（1/N+1）,默认值99，也就是垃圾收集时间不能超过总时间 的1%。

      -XX:UseAdaptiveSizePolicy   	设置自适应调节机制。


      ```

- 并发回收器
  - G1
  - ZGC

##### 垃圾回收器组合关系

![垃圾回收器组合关系](https://cdn.jsdelivr.net/gh/yougenchannel/imagehost/picture%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png)

##### CMS(Concurrent Mark Sweep)垃圾回收器（低延迟）

- 采用标记清除-算法，同样使用“stop the world” 。
- 作为老年代垃圾回收期，但是不能和 Parallel Scavenge 同时使用。
- 垃圾清理过程
  - 初始标记：标记出可达对象，在此过程中是有 Stop the world 的，但是由于可达对象较少，那么标记会非常迅速，不用花费较长时间
  - 并发标记：从 GC Root 开始遍历整个对象图的过程，整个时间比较长，但是是可以和用户线程并发执行的。
  - 重新标记： 修正并发标记期间，因为用户线程是并发执行的，可能有部分对象的状态发生了改变，需要重新标记。
  - 并发清除：清除掉垃圾已经死亡的对象，释放内存空间
- 由于垃圾回收过程中，用户线程还在执行，并且 CMS 垃圾回收需要较长的时间，所以在垃圾回收的过程中，应该保证用户还有足够的内存可用。

- **为什么 CMS 垃圾回收器使用标记-清除算法而不用标记整理算法 ？**
  - 因为 CMS 垃圾回收是和用户线程并发执行的，垃圾回收的过程中，用户线程还在执行，如果在此期间，使用 compact 算法的话，势必会导致一些对象地址的改变，影响用户资源的使用。所以 Mark-compact 更适合 stop the world
- CMS 优点
  - 并发收集
  - 低延时
- CMS 缺点
  - 会产生内存碎片（维护一个空闲列表）当内存不足以分配一个大对象时，可能会提前触发一次 Full GC
  - CMS 对 cpu 资源非常敏感，因为垃圾回收是和用户线程并发执行，虽然不会暂停用户线程，但是会占据部分 cpu 资源，导致应用程序变慢，总吞吐量降低。
  - CMS 无法清除浮动垃圾，因为在并发标记阶段，用户线程可能会产生新的垃圾，CMS 无法对这些新的垃圾进行标记。最终会导致这些新的垃圾没有被及时回收。
- 常见参数设置

```
-XX:+UseConcMarkSweepGC			手动指定使用CMS收集器执行内存回收任务
	--开启该参数会自动将-XX:+UseParNewGC 打开，及ParNew(Young区)+CMS(Old区) + Serial Old的组合。
-XX:CMSlnitiatingOccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始回收
	--在jdk5及以前的版本默认值为68，即当老年代垃圾回收率到达68%时，会执行一次CMS垃圾回收，jdk6以上版本默认值为92%。
	--如果内存增长较慢，那么可以设置一个稍大的值，大的阈值可以有效降低CMS的频率，减少老年代垃圾回收的次数从而较明显的改善应用程序的性能，当然如果内存增长较快
	--那么就应当适当降低该阈值，以免频繁触发老年代串行垃圾回收器（Serial Old GC）,因此通过此选项能够有效降低Full GC 的执行次数。

-XX:+UseCMSCompactAtFullCollection  -- 设置是否在执行fullGC后执行整理内存算法
-XX:CMSFullGcsBeforeCompaction 设置在执行多少次Full GC后对空间进行压缩整理
-XX:ParallelCMSThreads 设置CMS线程数量
```

##### G1（Garbage First）

- 全功能的收集器，愿景：在保证较高吞吐量的情况下还能保持低延迟。

- 将堆空间划分成多个互不相关的区域，维护一个优先列表，优先收集垃圾最多的区域（故叫 Garbage FIrst）。

- 在 jdk9 中成为默认的垃圾回收器

- 优点

  - G1 是兼具并行和并发的。

  - 分代收集

    ![G1垃圾回收](https://cdn.jsdelivr.net/gh/yougenchannel/imagehost/pictureG1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png)

    - 空间整合
      - Region 与 Region 之间是标记复制算法，但整体上可以看做是标记整理算法。

  - 可预测停顿时间模型

    - 能够让用户指定在长度为 M 毫秒的时间内，消耗在垃圾回收上的时间不得超过 N 毫秒。
    - 由于分区原因，G1 可以选择回收价值更大的区域进行垃圾回收，缩小了回收范围，那么就减少了停顿时间，也保证了在有限的时间内可以获得较高的垃圾回收效率.

- 缺点

  - 相较于 CMS，G1 还不具备全方位压倒性的优势，不如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载，都要比 CMS 高。
  - 从经验上来说在小程序上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势。平衡点在 6-8G 之间

- 常用参数设置

  ```


  -XX:+UseG1GC: 手动指定使用G1收集器执行内存回收任务。

  -XX:G1HeapRegionSize: 设置每个Region的大小。值是2的幂,范围是1MB到32MB之间,目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。

  -XX:MaxGCPauseMillis: 设置期望达到的最大GC停顿时间指标(JVM会尽力实现,但不保证达到)。默认值是200ms。

  -XX:ParallelGCThread: 设置STW时GC线程数的值。最多设置为8。

  -XX:ConcGCthreads: 设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右。

  -XX:InitiatingHeapOccupancyPercent: 设置触发并发GC周期的Java堆占用率阈值。超过此值,就触发GC。默认值是45
  ```

- G1 使用场景

  - G1 的第一个重点就是针对这样的场景：要求运行需要大堆且 GC 延迟有限的应用。这意味着堆大小在 6GB 左右或者更大，稳定和可预测停顿时间在 0.5 秒以下。
  - 不管是使用 CMS 还是 ParallelOld 回收器的应用，如果有以下特点，切换成 G1，会有一定的收益：
  - Full GC 耗时太长或者太频繁。
  - 对象分配率或提升率差异较大。
  - 回收或者压缩停顿时间太长（超过 0.5 或者 1 秒）

- 分代 Region

  - 每个 region 的大小相同，1m - 32m，且在 jvm 生命周期中都不会改变

  - 设置 Humongous 的原因：当一个 region 放不下一个大对象时，并且这个大对象超过了一个 region 的 1.5 倍，那么就会将该大对象扥配到 H 区

- G1 垃圾回收步骤
  - 年轻代垃圾回收（Young GC）
    - 扫描根（GCRoots）如静态变量，方法调用链中的局部变量等，同时还要包括 RSet 记录的外部引用作为扫描存活对象的入口
    - 更新 RSet(从 dirty card queue 中更新)保证 RSet 可以准确反应老年代对所在内存分段中的引用
    - 处理 RSet 识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象
    - 复制对象 遍历对象树，将 Eden 区中仍存活的对象复制到 Survivor 区中空的内存分段，Survivor 区内存断种存活的对象如果年龄还未达到阈值，会将其年龄+1，如果打到阈值会被复制到 Old 区中空闲的内存分段，如果 Survivor 区内存不够，那么 Eden 空间的部分数据会直接晋升到老年代空间。
    - 处理引用 处理
  - 老年代回收（和 CMS 步骤相同)
    - 初始标记（STW）
    - 根区域扫描，并发标记
    - 重新标记
    - 清除
    - 复制
- Remembered Set
  - 出现原因：
    - 因为在一个 region 中，其中某些对象可能会被其他 region 所引用，那么就需要全局扫描所有 Region，这不是我们想看到的，所有我们就需要一个记忆集来记录该区域是否有对象被其他对象所引用。
      - 写屏障 ：当一个对象将要放入到一个区域中，会先判断引用他的对象是否在同一个 region 中，如果不在，就会将该信息记录在卡表中。

### GC 日志分析

- 常用参数设置

```
-Xloggc:./logs/gc.log
```
